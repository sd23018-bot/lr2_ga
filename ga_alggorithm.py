# -*- coding: utf-8 -*-
"""GA Alggorithm.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sZ-BVMl8ro6Hd3zDRxVEvDqNaIz--fV9
"""

import numpy as np
import pandas as pd
import streamlit as st
from dataclasses import dataclass
from typing import Callable, List, Tuple
import random

# -------------------- Problem Definition --------------------
@dataclass
class GAProblem:
    name: str
    chromosome_type: str  # 'bit'
    dim: int
    fitness_fn: Callable[[np.ndarray], float]

# Custom fitness function per Question 2
def make_custom_bit_problem(dim: int = 80) -> GAProblem:
    def fitness(x: np.ndarray) -> float:
        num_ones = np.sum(x)
        # Formula: maximum fitness (80) when number of ones = 50
        return 80 - abs(50 - num_ones)

    return GAProblem(
        name="Custom Bit Pattern Optimization",
        chromosome_type="bit",
        dim=dim,
        fitness_fn=fitness
    )

# -------------------- GA Core Functions --------------------
def init_population(problem: GAProblem, pop_size: int) -> np.ndarray:
    return np.random.randint(0, 2, size=(pop_size, problem.dim), dtype=np.int8)

def evaluate(pop: np.ndarray, problem: GAProblem) -> np.ndarray:
    return np.array([problem.fitness_fn(ind) for ind in pop], dtype=float)

def tournament_selection(fitness: np.ndarray, k: int) -> int:
    idxs = np.random.randint(0, fitness.size, size=k)
    return idxs[np.argmax(fitness[idxs])]

def one_point_crossover(a: np.ndarray, b: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    point = np.random.randint(1, len(a))
    c1 = np.concatenate([a[:point], b[point:]])
    c2 = np.concatenate([b[:point], a[point:]])
    return c1, c2

def bit_mutation(x: np.ndarray, mut_rate: float) -> np.ndarray:
    mask = np.random.random(x.shape) < mut_rate
    y = x.copy()
    y[mask] = 1 - y[mask]
    return y

# -------------------- Genetic Algorithm --------------------
def run_ga(problem: GAProblem, pop_size=300, generations=50, crossover_rate=0.9, mutation_rate=0.01, tournament_k=3, elitism=2):
    pop = init_population(problem, pop_size)
    fit = evaluate(pop, problem)

    best_history, avg_history = [], []

    for gen in range(generations):
        best_fit = np.max(fit)
        avg_fit = np.mean(fit)
        best_history.append(best_fit)
        avg_history.append(avg_fit)

        # Elitism
        elite_idx = np.argsort(fit)[-elitism:]
        elites = pop[elite_idx]

        new_pop = []
        while len(new_pop) < pop_size - elitism:
            i1 = tournament_selection(fit, tournament_k)
            i2 = tournament_selection(fit, tournament_k)
            p1, p2 = pop[i1], pop[i2]

            # Crossover
            if random.random() < crossover_rate:
                c1, c2 = one_point_crossover(p1, p2)
            else:
                c1, c2 = p1.copy(), p2.copy()

            # Mutation
            c1 = bit_mutation(c1, mutation_rate)
            c2 = bit_mutation(c2, mutation_rate)

            new_pop.extend([c1, c2])

        # Form new population
        pop = np.vstack([np.array(new_pop[:pop_size - elitism]), elites])
        fit = evaluate(pop, problem)

    best_idx = np.argmax(fit)
    best = pop[best_idx]
    return best, fit[best_idx], best_history, avg_history

# -------------------- Streamlit UI --------------------
st.set_page_config(page_title="Genetic Algorithm - Bit Pattern Optimization", page_icon="ğŸ§¬", layout="wide")

st.title("ğŸ§¬ Genetic Algorithm â€” Bit Pattern Optimization")
st.write("""
This GA evolves an 80-bit pattern to maximize the fitness function:
**f(x) = 80 - |50 - number_of_ones(x)|**,
which reaches its maximum (80) when exactly 50 bits are 1.
""")

# Fixed parameters per question
POP_SIZE = 300
GENERATIONS = 50
CHROMO_LENGTH = 80

# Optional user adjustments
crossover_rate = st.slider("Crossover rate", 0.0, 1.0, 0.9)
mutation_rate = st.slider("Mutation rate", 0.0, 0.1, 0.01)
elitism = st.slider("Elites per generation", 0, 10, 2)
tournament_k = st.slider("Tournament size", 2, 10, 3)

if st.button("Run Genetic Algorithm"):
    problem = make_custom_bit_problem(dim=CHROMO_LENGTH)
    best, best_fit, best_history, avg_history = run_ga(
        problem,
        pop_size=POP_SIZE,
        generations=GENERATIONS,
        crossover_rate=crossover_rate,
        mutation_rate=mutation_rate,
        tournament_k=tournament_k,
        elitism=elitism
    )

    # Results
    st.subheader("ğŸ“ˆ Fitness Over Generations")
    df = pd.DataFrame({
        "Best Fitness": best_history,
        "Average Fitness": avg_history
    })
    st.line_chart(df)

    st.subheader("ğŸ† Best Individual")
    bitstring = ''.join(map(str, best))
    st.code(bitstring, language="text")
    st.write(f"**Number of 1s:** {int(np.sum(best))}")
    st.write(f"**Best Fitness:** {best_fit:.2f}")

    if np.sum(best) == 50:
        st.success("âœ… Perfect solution found (50 ones, fitness = 80)!")
    else:
        st.info("Optimization complete â€” target not yet perfect, try running again.")